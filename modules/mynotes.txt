
---- aura related function call sequence ----

= MODULE WRAPPING
ShadowUF wrapps the lua module registering with ShadowUF:RegisterModule method.


= ZONE MONITOR
ShadowedUnitFrames.lua:
- ShadowUF:OnInitialize()
	- LoadDefaultLayout()
		> for each item in ShadowUF.unitList call 
		modules/units.lua:
		- ShadowUF.Units:InitializeFrame()
		- ShadowUF.Units:LoadUnit()
		- centralFrame:SetScript("OnEvent", function)
			- ShadowUF.Units:CheckPlayerZone()
				- for each frame in call
				> ShadowUF.modules.auras:UpdateFilter()
				modules/auras.lua:
				- updates black/white/override lists these are used on aura init/update.

= AURA EVENT CALLBACKS
modules/auras.lua:
- Auras:OnEnable(frame)
	- creates (new) table for auras: frame.auras = frame.auras or {}
	- Auras:UpdateFilter(frame)
	- frame:RegisterUnitEvent("UNIT_AURA", self, "UPDATE")
		- Auras:Update(frame)
			- loads config from db.
			- scans for auras by calling 'scan' function for all kinds of auras
			- anchors auras on buffs or debuffs if activated.
			> scan(parent, frame, type, config, displayConfig, filter)
				- categorizes aura:
					- isFriendly, curable
					- index = 0 <--- just an initial index, updated elsewhere!
				- calls UnitAura constructor to render it via 'renderAura' function.
				> renderAura(parent, frame, type, config, displayConfig, index, filter, isFriendly, curable, name, texture, count, auraType, duration, endTime, caster, isRemovable, nameplateShowPersonal, spellID, canApplyAura, isBossDebuff)
					- categorizeAura(type, curable, auraType, caster, isRemovable, canApplyAura, isBossDebuff)
					- applies whitelist/blacklist/override and type filters.
					- creates buttons (ace lib i guess!), uses incrementing counter as aura id.
					- creates button border etc.
					> updateButton(frame.totalAuras, frame, ShadowUF.db.profile.units[frame.parent.unitType].auras[frame.type]))					
						- positionButton(id, group, config)!
